#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section
What is Dark Programming?
\end_layout

\begin_layout Enumerate
Traditional programmig involves a subjective method (or process) designed
 to solve a problem and which satisfies some rationale.
\begin_inset CommandInset citation
LatexCommand cite
key "DarkProg"

\end_inset

 This rationale is typically managed by the programmer in the form of a
 set of guiding sound engineering principles.
\begin_inset CommandInset citation
LatexCommand cite
key "DarkProg"

\end_inset


\end_layout

\begin_layout Enumerate
A dark program is the product of some technique involving emergent behavior
 and so it does not depend on or involve any subjective method and use of
 rationales, it is not constrained to obey sound engineering principles.
 
\begin_inset CommandInset citation
LatexCommand cite
key "DarkProg"

\end_inset


\end_layout

\begin_layout Enumerate
A dark program is either a proper program, we just haven't satisfied ourselves
 that it can be rationally exlained yet, or it is not a program, because
 it cannot be rationally explained by the justification criterion.
 
\begin_inset CommandInset citation
LatexCommand cite
key "DarkProg"

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Where the justification criterion is:
\end_layout

\begin_deeper
\begin_layout Enumerate
the structure of the program can be explained by the way it contrubutes
 to achieving some goal 
\begin_inset CommandInset citation
LatexCommand cite
key "DarkProg"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Sound engineering principles are a set of desireable properties including
\end_layout

\begin_deeper
\begin_layout Enumerate
Understandability
\end_layout

\begin_deeper
\begin_layout Enumerate
Predictability
\end_layout

\begin_layout Enumerate
Testability
\end_layout

\end_deeper
\begin_layout Enumerate
Maintainability
\end_layout

\begin_deeper
\begin_layout Enumerate
Modifiability
\end_layout

\begin_layout Enumerate
Amenability to:
\end_layout

\begin_deeper
\begin_layout Enumerate
location and correction of errors and performance deficiencies
\end_layout

\begin_layout Enumerate
verification and validation efforts
\end_layout

\end_deeper
\begin_layout Enumerate
Enabling of the division of work
\end_layout

\end_deeper
\begin_layout Enumerate
Reusability - Reuse of solutions in future designes
\end_layout

\end_deeper
\begin_layout Enumerate
Darkness of a program in the context of the above problem, is then the quantific
ation of our ability to understand both the execution of the program, the
 underlying process embedded in the program, and the design consideration
 motivating the creation of this program.
\end_layout

\begin_layout Enumerate
If we then assume that we can immediately propose a means by which we can
 adjust the structure of the program, not changing its functionality, in
 such a way that it conforms to current sound engineering principles, then
 we have begun the arduous process of 
\begin_inset Quotes eld
\end_inset

lightening
\begin_inset Quotes erd
\end_inset

 the program.
 That is, using software engineering metrics which measure the desireable
 properties mentioned above, we can begin to use techniques, refactoring,
 to adjust the programs structure.
 Where, refactoring is a method specifically designed to alter only the
 structure and not the function, we can then ease the ability to understand
 the software.
 Given that these processes are themselve assumed to be in keeping with
 sound engineering principles, the underlying design choices are immediately
 understood and all that is truly left is understanding the operation of
 the program.
 Therefore, since the understanding of the program execution is itself not
 what makes the program dark, but instead it is the lack of existing knowledge
 of the rationality of the program, and given that this process infuse rationale
 into the program, we have in effect lightened the program.
\end_layout

\begin_layout Enumerate
Given that we can design this process and apply this method.
 Then we can provide a piece of software which can automatically apply code
 refactoring techniques to an existing bank of code.
 This then can allow developers, when provided with an older piece of software
 which they do not understand, to refactor and reshape the code into something
 they can quickly understand and with complementary documentation, which
 also eases the ability to understand a project.
 As more and more software is being built to serve various customers we
 need such tools to ensure not only that code remains within the scope of
 best practices as defined by software engineering, but we also need such
 a tool to maximize the developer's efficiency and productive time.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
Dark Programming was a concept proposed by Janlert, which describes both
 certain types of programs as well as the notion of understandability in
 programs.
 The concept Janlert proposed is a criterion by which we can judge the measure
 of source code and by which we can call it a program.
 The third criteria was a notion of rationality.
 It is this notion of rationality that certain programs, such as those using
 Evolutionary/Genetic algorithms as well as Artificial Neural Networks,
 do have and cannot truly be called a program.
 If we look deeper into this proposed notion of rationality we can see that
 it is an attempt to really describe the act of writing a computer program,
 where a program will both describe a subjective notion of a process and
 instaneously objectify it, and it also describes the understanding that
 is inherent in the program that other programmers will have just by reading
 it.
 It can then be seen that by this concept of rationality we could not call
 Evolutionary Programs or ANNs rational due to their emergent behaviors.
 But, we can also see a problem in the underlying practice of software engineeri
ng as well.
 That is as time passes and a piece of software evolves, the general practice
 of software engineering changes.
 That is, new techniques and technologies develop allowing software to be
 better designed.
 Sadly older software may not be maintained in a way that keeps up with
 the best practices of the day.
 It should also be mentioned that as software engineering techniques have
 changed a focus on reusability and maintainability have become a greater
 focus.
 As for these older software artifacts, reusing existing code or maintaining
 existing banks of code becomes increasingly more difficult as software
 design teams change and techniques and technologies change.
 The latter two issues, design team changes and evolving techniques and
 technologies, lead to a steady decrease in the understandability, reusability,
 and maintainability of older software.
 It also forces programmers to consistently reinvent or rework solutions
 to problems that have already been solved, by recreating code that may
 already exist within their organization or within their reach.
\end_layout

\begin_layout Standard
This steady decline in the understanability, reusability, and maintainability
 of older software is itself the darkening of that software.
 That is it falls within the proposed definition of the lack of rationality
 in code and hence makes these programs no longer rational programs.
 Yet, as Janlert has proposed we may be able to develop a tool using dark
 programming (EvoAlgs and ANNs) to provide rational light to currently dark
 programs.
 Assuming that these older programs were not originally designed as dark
 programs, then we know that the understanding orginally conveyed by the
 original team of designers is still there and only needs to be uncovered.
 Given this assumption there exists techniques to recover this understanding
 as well as enhance and expedite the potential understanding for all programmers.
 Janlert has proposed in his concluding remarks that by using Dark Programming
 techniques we could provide the rational basis of other programs and perhaps
 even the Dark Program itself.
 This can be compared to reverse engineering, to discover how a piece of
 software works, and then reengineering it to comply with current best practices
 from software engineer.
\end_layout

\end_body
\end_document
